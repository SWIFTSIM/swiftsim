#!/usr/bin/env python
#
# Usage:
#  python plot_scaling_results_detailed.py input-file-1 input-file-2
#
# Description:
# Plots speed up, parallel efficiency and time to solution given the output file generated by SWIFT.
# You need to run SWIFT with -v 1.
#
# Example:
# python plot_scaling_results_detailed.py output_1.log output_2.log

import sys
import re
import numpy as np
import matplotlib.pyplot as plt

from timed_functions import labels

params = {
    "axes.labelsize": 14,
    "axes.titlesize": 18,
    "font.size": 12,
    "legend.fontsize": 12,
    "xtick.labelsize": 14,
    "ytick.labelsize": 14,
    "text.usetex": True,
    "figure.subplot.left": 0.055,
    "figure.subplot.right": 0.98,
    "figure.subplot.bottom": 0.05,
    "figure.subplot.top": 0.95,
    "figure.subplot.wspace": 0.14,
    "figure.subplot.hspace": 0.12,
    "lines.markersize": 6,
    "lines.linewidth": 2.0,
}
plt.rcParams.update(params)

legendTitle = " "

hexcols = [
    "#332288",
    "#88CCEE",
    "#44AA99",
    "#117733",
    "#999933",
    "#DDCC77",
    "#CC6677",
    "#882255",
    "#AA4499",
    "#661100",
    "#6699CC",
    "#AA4466",
    "#4477AA",
]
colors = [
    hexcols[0],
    hexcols[1],
    hexcols[3],
    hexcols[5],
    hexcols[6],
    hexcols[8],
    hexcols[2],
    hexcols[4],
    hexcols[7],
]

linestyle = [
    "-",
    "--",
    "-.",
    ":"
]

# Work out how many data series there are
if len(sys.argv) == 1:
    print("Please specify an input file in the arguments.")
    sys.exit()
else:
    filenames = sys.argv[1:]

# Parse file and return total time taken, speed up and parallel efficiency
def parse_files():

    # Allocate the arrays
    n_labels = len(labels)
    n_files = len(filenames)

    total_time = np.zeros((n_labels, n_files))
    threads = np.zeros(n_files)

    for i, filename in enumerate(filenames):  # Loop over each file
        print("Files read %.1f%%\r" % (100 * i / n_files), end="")
        # Open stdout file
        with open(filename, "r") as f:

            # Search the different phrases
            for line in f:

                # Extract the number of threads
                if re.search("threads / rank and", line):
                    all_numbers = re.findall(r"[+-]?((\d+\.?\d*)|(\.\d+))", line)
                    rank = int(all_numbers[5][0])
                    thread = int(all_numbers[6][0])
                    threads[i] = rank * thread

                # Loop over the possbile labels
                for j in range(n_labels):

                    # Extract the different blocks
                    if re.search("%s took" % labels[j][0], line):

                        total_time[j, i] += float(
                            re.findall(r"[+-]?((\d+\.?\d*)|(\.\d+))", line)[-1][0]
                        )

                # Find the last line with meaningful output (avoid crash report, batch system stuff....)
                if re.findall(r"\[[0-9]{4}\][ ]\[*", line) or re.findall(
                        r"^\[[0-9]*[.][0-9]+\][ ]", line):
                    lastline = line

    # Remove the functions not found
    time = np.sum(total_time, axis=1)
    ind = time == 0.
    total_time = np.delete(total_time, ind, axis=0)
    for i in range(n_labels)[::-1]:
        if ind[i]:
            del labels[i]
    n_labels = len(labels)

    # Sort according to the threads number
    ind = np.argsort(threads)
    threads = threads[ind]
    for i in range(n_labels):
        total_time[i, :] = total_time[i, ind]

    print("\nNumber of threads found", threads)

    # Avoid division by 0
    total_time[total_time == 0.] = 1e-6

    # Find speed-up and parallel efficiency
    speed_up = total_time[:, 0][:, np.newaxis] / total_time
    parallel_eff = speed_up / threads

    return threads, total_time, speed_up, parallel_eff


def plot_results(threads, total_time, speed_up, parallel_eff):
    n_files = len(filenames)
    n_labels = len(labels)

    fig, axarr = plt.subplots(2, 2, figsize=(10, 10), frameon=True)
    speed_up_plot = axarr[0, 0]
    parallel_eff_plot = axarr[0, 1]
    total_time_plot = axarr[1, 0]
    empty_plot = axarr[1, 1]

    # Plot speed up
    speed_up_plot.plot(threads, threads, linestyle="--", lw=1.5, color="0.2")
    for i in range(n_labels):
        i_line = i % len(linestyle)
        i_color = i % len(colors)
        speed_up_plot.plot(threads, speed_up[i, :], c=colors[i_color],
                           linestyle=linestyle[i_line])

    speed_up_plot.set_ylabel("${\\rm Speed\\textendash up}$", labelpad=0.0)
    speed_up_plot.set_xlabel("${\\rm Threads}$", labelpad=0.0)
    speed_up_plot.set_xlim([0.7, threads.max() + 1])
    speed_up_plot.set_ylim([0.7, threads.max() + 1])

    # Plot parallel efficiency
    for i in range(n_labels):
        i_line = i % len(linestyle)
        i_color = i % len(colors)
        parallel_eff_plot.plot(threads, parallel_eff[i, :], c=colors[i_color],
                               linestyle=linestyle[i_line])

    parallel_eff_plot.set_xscale("log")
    parallel_eff_plot.set_ylabel("${\\rm Parallel~efficiency}$", labelpad=0.0)
    parallel_eff_plot.set_xlabel("${\\rm Threads}$", labelpad=0.0)
    parallel_eff_plot.set_ylim([0, 1.1])
    parallel_eff_plot.set_xlim([0.9, 10 ** (np.floor(np.log10(threads.max())) + 0.5)])

    # Plot time to solution
    pts = np.array([1, 10 ** np.floor(np.log10(threads.max()) + 1)])
    total_time_plot.loglog(pts, 1. / pts, "k--", lw=1.0, color="0.2")
    for i in range(n_labels):
        i_line = i % len(linestyle)
        i_color = i % len(colors)
        label = labels[i][0].replace("_", "\_")
        total_time_plot.loglog(
            threads, total_time[i, :], c=colors[i_color],
            linestyle=linestyle[i_line], label=label)

    y_min = 10 ** np.floor(np.log10(total_time.min() * 0.6))
    y_max = 1.0 * 10 ** np.floor(np.log10(total_time.max() * 1.5) + 1)
    total_time_plot.set_xscale("log")
    total_time_plot.set_xlabel("${\\rm Threads}$", labelpad=0.0)
    total_time_plot.set_ylabel("${\\rm Time~to~solution}$", labelpad=0.0)
    total_time_plot.set_xlim([0.9, 10 ** (np.floor(np.log10(threads.max())) + 0.5)])
    total_time_plot.set_ylim(y_min, y_max)

    total_time_plot.legend(
        bbox_to_anchor=(1.21, 0.97),
        loc=2, ncol=2,
        borderaxespad=0.0,
        prop={"size": 12},
        frameon=False,
    )
    empty_plot.axis("off")

    fig.suptitle(
        "${\\rm Speed\\textendash up,~parallel~efficiency~and~time~to~solution}$",
        fontsize=16,
    )

    return


# Calculate results
threads, total_time, speed_up, parallel_eff = parse_files()

print("Functions found: ", [l[0] for l in labels])

plot_results(threads, total_time, speed_up, parallel_eff)
# And plot
plt.show()
