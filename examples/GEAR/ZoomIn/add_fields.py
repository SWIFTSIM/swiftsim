#!/usr/bin/env python3

import numpy as np
import yt.utilities.physical_constants as constants
from yt.mods import YTArray
from yt import derived_field


def addMassDeposit(f):
    f.add_deposited_particle_field(("all", "Masses"), "sum")


def addTemperature(f):
    """
    Add the temperature field.

    Parameters
    ----------

    f: yt dataset
        The dataset that needs the temperature
    """

    def calc_mu_table_local(temperature):
        """
        From grackle/src/python/utilities/convenience.py: Calculate a tabulated
        approximation to mean molecular weight (valid for data that used
        Grackle 2.0 or below)
        """
        tt = np.array([1.0e+01, 1.0e+02, 1.0e+03, 1.0e+04, 1.3e+04, 2.1e+04,
                       3.4e+04, 6.3e+04, 1.0e+05, 1.0e+09])
        mt = np.array([1.18701555, 1.15484424, 1.09603514, 0.9981496,
                       0.96346395, 0.65175895, 0.6142901, 0.6056833, 0.5897776,
                       0.58822635])
        logttt = np.log(temperature)
        # linear interpolation in log-log space
        logmu = np.interp(logttt, np.log(tt), np.log(mt))
        return np.exp(logmu)

    temperature_values = []
    mu_values = []
    T_over_mu_values = []
    current_temperature = 1e1
    final_temperature = 1e7
    dlogT = 0.1

    while current_temperature < final_temperature:
        temperature_values.append(current_temperature)
        current_mu = calc_mu_table_local(current_temperature)
        mu_values.append(current_mu)
        T_over_mu_values.append(current_temperature/current_mu)
        current_temperature = np.exp(np.log(current_temperature)+dlogT)

    def convert_T_over_mu_to_T(T_over_mu):
        logT_over_mu = np.log(T_over_mu)
        # linear interpolation in log-log space
        logT = np.interp(logT_over_mu, np.log(T_over_mu_values),
                         np.log(temperature_values))
        return np.exp(logT)

    def _Temperature_3(field, data):
        gamma = 5.0/3.0
        T_over_mu = (data["PartType0", "InternalEnergy"] * (gamma-1)
                     * constants.mass_hydrogen_cgs /
                     constants.boltzmann_constant_cgs).in_units('K').d  # T/mu
        return YTArray(convert_T_over_mu_to_T(T_over_mu), 'K')  # now T
    f.add_field(("PartType0", "Temperature"), function=_Temperature_3,
                particle_type=True, force_override=True, units="K")


def addMetals(f):
    def _metallicity(field, data):
        if len(data["PartType0", "Metals"].shape) == 1:
            return data["PartType0", "Metals"]
        else:
            # in_units("") turned out to be crucial!;
            # otherwise code_metallicity will be used
            return data["PartType0", "Metals"][:, -1].in_units("")

    # We are creating ("Gas", "Metallicity") here, different from
    # ("Gas", "metallicity") which is auto-generated by yt
    # but doesn't work properly
    f.add_field(("PartType0", "Metallicity"), function=_metallicity,
                display_name="Metal mass fraction", particle_type=True,
                take_log=True, units="")

    def _density_squared(field, data):
        return data[("PartType0", "density")]**2
    f.add_field(("PartType0", "density_squared"), function=_density_squared,
                particle_type=True, units="g**2/cm**6")
